Part 1
1.	자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
1.1.	역사의 흐름은 무엇인가?
-	자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반
-	스트림 API : 표현식을 처리하는 것처럼 병렬 연산을 지원, 값싼 비용
-	메서드에 코드 전달 : 전달의 단순화, 효율화
-	디폴트 메서드 제공 : 인터페이스의 확장

1.2.	왜 아직도 자바는 변화하는가?
1.2.1.	프로그래밍 언어 생태계에서 자바의 위치
-	JVM을 이용한 확장성, 객체지향언어로 좋은 출발을 가짐
-	유저, 시대의 흐름에 따라 변화하고 있고 자바 8에서 많은 부분이 변경됨

1.2.2.	스트림 처리
-	스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목의 모임. 한 개씩 읽고 한 개씩 기록
-	자바 8 이후 스트림 API는 여러 CPU 할당, 파이프라인 설계 등 다양한 기능을 지원
-	병렬성을 얻을 수 있음

1.2.3.	동작 파라미터화로 메서드에 코드 전달하기
-	메서드에 원하는 기능을 쉽게 커스터마이징 할 수 있도록 도와줌
-	자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공 -> 동적 파라미터화

1.2.4.	병렬성과 공유 가변 데이터
-	공유 가변 데이터 : 여러 프로세스가 공유하는 데이터. 병렬적으로 접근시 데이터가 꼬이는 문제가 발생할 수 있음.
-	자바 8 스트림에서는 병렬성을 쉽게 확보할 수 있음

1.2.5.	자바가 진화해야 하는 이유
-	언어는 하드웨어나 프로그래머의 기대에 부응하는 방향으로 변화해야 한다.

1.3.	자바 함수
1.3.1.	메서드와 람다를 일급 시민으로
-	메서드를 값으로 취급할 수 있는 기능을 자바 8에 추가
-	일급 객체 : 변수나 데이터에 할당 가능 && 객체의 인자로 넘길 수 있음 && 객체의 리턴값으로 반환할 수 있음
-	매서드 참조 : 매서드를 값으로 취급하여 사용할 수 있는 방식. (::매서드) 형식으로 이용 가능. (후에 서술)
-	람다 익명 함수 : 람다 혹은 익명함수도 마찬가지로 값으로 취급할 수 있다. 이용할 수 있는 편리한 클래스나 매서드가 없을 때 람다 문법을 이용하면 더욱 간결하게 코드를 구현할 수 있다.

1.3.2.	코드 넘겨주기 : 예제
-	함수의 파라미터에 함수를 입력할 수 있다.
-	Ex) filterApples(inventory, Apple::isGreenApple);
-	프레디케이트 : 파라미터를 받아 TF를 반환하는 형태

1.3.3.	메서드 전달에서 람다로
-	일회성 메서드를 정의할 때 유용
-	짧고 간결
-	Ex) filterApple(inventory, (Apple a) -> a.getWeight() > 150);

1.4.	스트림
-	스트림 API는 코드를 분명하고 간결하게 한다.(필터링, 추출, 그룹화 등을 이용)
-	외부 반복 : for문을 이용해 각 요소를 외부에서 반복하여 처리하는 방식
-	내부 반복 : 라이브러리 내부에서 데이터를 처리하는 방식
-	거대한 데이터를 멀티코어를 이용해 병렬로 작업을 수행한다.
-	컬랙션은 데이터의 저장, 접근에 중점을 두는 반면, 스트림은 데이터의 계산에 중점을 둔다

1.4.1.	멀티스레딩은 어렵다
-	공유된 데이터의 접근 문제로 데이터를 잘 제어하지 못하면 다른 결과가 나올 수 있음
-	양쪽에서 접근하는 등 다양한 방식으로 데이터를 제어
1.5.	디폴트 메서드와 자바 모듈
-	기존 자바 인터페이스는 상속 받은 함수가 인터페이스 함수를 반드시 선언해야 했었다. 이는 새로운 인터페이스 확장에 큰 걸림돌이었고, 이를 해결하기 위해 함수에 default를 선언하여 구현 의무를 지웠다.

1.6.	함수형 프로그래밍에서 가져온 다른 유용한 아이디어
-	
1.7.	마치며

2.	동작 파라미터화 코드 전달하기
2.1.	변화하는 요구사항에 대응하기
2.1.1.	첫번째 시도 : 녹색 사과 필터링
2.1.2.	두번째 시도 : 색을 파라미터화
2.1.3.	세번째 시도 : 가능한 모든 속성으로 필터링
2.2.	동작 파라미터화
2.2.1.	네번재 시도 : 추상적 조건으로 필터링
2.3.	복잡한 과정 간소화
2.3.1.	익명 클래스
2.3.2.	다섯번재 시도 : 익명 클래스 사용
2.3.3.	여섯번재 시도 : 람다 표현식 사용
2.3.4.	일곱번째 시도 : 리스트 형식으로 추상화
2.4.	실전 예전
2.4.1.	Comparator로 정렬하기
2.4.2.	Runnable로 코드 블록 실행하기
2.4.3.	Callable을 결과로 반환하기
2.4.4.	GUI 이벤트 처리하기
2.5.	마치며

3.	람다 표현식
3.1.	람다란 무엇인가?
3.2.	어디에, 어떻게 람다를 사용할까?
3.2.1.	함수형 인터페이스
3.2.2.	함수 디스크립터
3.3.	람다 활용 : 실행 어라운드
3.3.1.	1단계 : 동작 파라미터화를 기억하라
3.3.2.	2단계 : 함수형 인터페이스를 이용하여 동작 전달
3.3.3.	3단계 : 동작 실행
3.3.4.	4단계 : 람다 전달
3.4.	함수형 인터페이스 사용
3.4.1.	Predicate
3.4.2.	Consumer
3.4.3.	Function
3.5.	형식 검사, 형식 추론, 제약
3.5.1.	형식 검사
3.5.2.	같은 람다, 다른 함수형 인터페이스
3.5.3.	형식 추론
3.5.4.	지역 변수 사용
3.6.	메서드 참조
3.6.1.	요약
3.6.2.	생성자 참조
3.7.	람다, 메서드 참조 활용하기
3.7.1.	1단계 : 코드 전달
3.7.2.	2단계 : 익명 클래스
3.7.3.	3단계 : 람다 표현식 사용
3.7.4.	4단계 : 메서드 참조 사용
3.8.	람다 표현식을 조합할 수 있는 유용한 메서드
3.8.1.	Comparator 조합
3.8.2.	Predicate 조합
3.8.3.	Function 조합
3.9.	비슷한 수학적 개념
3.9.1.	적분
3.9.2.	자바 8 람다로 연결
3.10.	마치며

