# 1, 2, 3장

1. 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?
    - 역사의 흐름은 무엇인가?
        - 자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용을 기반
        - 스트림 API : 표현식을 처리하는 것처럼 병렬 연산을 지원, 값싼 비용
        - 메서드에 코드 전달 : 전달의 단순화, 효율화
        - 디폴트 메서드 제공 : 인터페이스의 확장
        
    - 왜 아직도 자바는 변화하는가?
        - 프로그래밍 언어 생태계에서 자바의 위치
            - JVM을 이용한 확장성, 객체지향언어로 좋은 출발을 가짐
            - 유저, 시대의 흐름에 따라 변화하고 있고 자바 8에서 많은 부분이 변경됨
        - 스트림 처리
            - 스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목의 모임. 한 개씩 읽고 한 개씩 기록
            - 자바 8 이후 스트림 API는 여러 CPU 할당, 파이프라인 설계 등 다양한 기능을 지원
            - 병렬성을 얻을 수 있음
        - 동작 파라미터화로 메서드에 코드 전달하기
            - 메서드에 원하는 기능을 쉽게 커스터마이징 할 수 있도록 도와줌
            - 자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공 -> 동적 파라미터화
        - 병렬성과 공유 가변 데이터
            - 공유 가변 데이터 : 여러 프로세스가 공유하는 데이터. 병렬적으로 접근시 데이터가 꼬이는 문제가 발생할 수 있음.
            - 자바 8 스트림에서는 병렬성을 쉽게 확보할 수 있음
        - 자바가 진화해야 하는 이유
            - 언어는 하드웨어나 프로그래머의 기대에 부응하는 방향으로 변화해야 한다.
            
    - 자바 함수
        - 메서드와 람다를 일급 시민으로
            - 메서드를 값으로 취급할 수 있는 기능을 자바 8에 추가
            - 일급 객체 : 변수나 데이터에 할당 가능 && 객체의 인자로 넘길 수 있음 && 객체의 리턴값으로 반환할 수 있음
            - 매서드 참조 : 매서드를 값으로 취급하여 사용할 수 있는 방식. (::매서드) 형식으로 이용 가능. (후에 서술)
            - 람다 익명 함수 : 람다 혹은 익명함수도 마찬가지로 값으로 취급할 수 있다. 이용할 수 있는 편리한 클래스나 매서드가 없을 때 람다 문법을 이용하면 더욱 간결하게 코드를 구현할 수 있다.
        - 코드 넘겨주기 : 예제
            - 함수의 파라미터에 함수를 입력할 수 있다.
            - Ex) filterApples(inventory, Apple::isGreenApple);
            - 프레디케이트 : 파라미터를 받아 TF를 반환하는 형태
        - 메서드 전달에서 람다로
            - 일회성 메서드를 정의할 때 유용
            - 짧고 간결
            - Ex) filterApple(inventory, (Apple a) -> a.getWeight() > 150);
            
    - 스트림
        - 스트림 특징
            - 스트림 API는 코드를 분명하고 간결하게 한다.(필터링, 추출, 그룹화 등을 이용)
            - 외부 반복 : for문을 이용해 각 요소를 외부에서 반복하여 처리하는 방식
            - 내부 반복 : 라이브러리 내부에서 데이터를 처리하는 방식
            - 거대한 데이터를 멀티코어를 이용해 병렬로 작업을 수행한다.
            - 컬랙션은 데이터의 저장, 접근에 중점을 두는 반면, 스트림은 데이터의 계산에 중점을 둔다
        - 멀티스레딩은 어렵다
            - 공유된 데이터의 접근 문제로 데이터를 잘 제어하지 못하면 다른 결과가 나올 수 있음
            - 양쪽에서 접근하는 등 다양한 방식으로 데이터를 제어
            
    - 디폴트 메서드와 자바 모듈
        - 기존 자바 인터페이스는 상속 받은 함수가 인터페이스 함수를 반드시 선언해야 했었다. 이는 새로운 인터페이스 확장에 큰 걸림돌이었고, 이를 해결하기 위해 함수에 default를 선언하여 구현 의무를 지웠다.
        
    - 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
    
    - 마치며

1. 동작 파라미터화 코드 전달하기
    - 변화하는 요구사항에 대응하기
        - 새로운 요구에 대응하기 위한 기존 코드는 DRY(do not repeat yourself) 원칙을 어긴다.
        - 동작 파리미터화를 이용해 이를 지키고 유연성을 얻을 수 있다
        
    - 동작 파라미터화
        - 프리티케이트 : 어떤 속성에 기초에 불리언값을 반환하는 함수
        - 프리티케이트를 implement하여 원하는 동작을 추가할 수 있다.
        - 프리티케이트에 상속 받은 함수를 객체로 초기화하여 인수로 이용할 수 있다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1eca7279-2e15-4f60-9c17-1d41db54fd08/Untitled.png)
        
    
    - 복잡한 과정 간소화
        - 익명 클래스
        - 다섯번째 시도 : 익명 클래스 사용
            - 익명 클래스 : 클래스 선언과 인스턴스화를 동시에 진행. 즉석해서 필요한 구현을 만들어서 사용 가능
            - 역시 코드길이가 길어지고 많은 사람들이 익숙치 않다
        - 여섯번째 시도 : 람다 표현식 사용
            - (입력 파라미터) → 반환값 형식으로 사용
            - 이전에 길게 썼던 동작 함수를 입력 파라미터와 반환값으로 줄여버림
        - 일곱번째 시도 : 리스트 형식으로 추상화
            - 제네릭을 이용하여 데이터 타입을 다양화 및 임의 지정 할 수 있다. 이는 람다함수의 넓은 이용을 가능하게 만든다
            
    - 실전 예전
        - Comparator, Runnable, Callable, GUI 예제
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d2bf483c-df7e-4d84-b838-d2a9fb43de2c/Untitled.png)
        
    
    - 마치며
        - 동작 파라미터화에서는 다양한 동작을 수행할 수 있도록 코드를 메서드 인수로 전달
        - 동작 파라미터화를 이용하면 변화에 더 잘 대응할 수 있음
        - 자바 8 이후의 코드 전달 기법(람다 표현식)은 여러 클래스를 구현해야 하는 수고를 줄일 수 있다.
        - 자바 API의 많은 메서드는 다양한 동작으로 파라미터화 가능.
        
2. 람다 표현식
    - 람다란 무엇인가?
        - 람다 표현식 : 익명 함수를 단순화 한 것 (선언과 동시에 인스턴스를 진행하는 익명함수를 군더더기 없이 깔끔하게 적용시키는 형식)
        
    - 어디에, 어떻게 람다를 사용할까?
        - 함수형 인터페이스
            - 함수형 인터페이스 : 정확히 하나의 추상 메서드를 지정하는 인터페이스. 디폴트 메서드는 몇개가 있던지 상관 없다
        - 함수 디스크립터
            - 함수 디스크립터 : 람다의 시그니처를 서술하는 메서드
        - 정리
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9aa7efe9-b68e-4f7c-b56e-a1cd4ce7f6c7/Untitled.png)
        
    
    - 람다 활용 : 실행 어라운드
        - 1단계 : 동작 파라미터화를 기억하라
            - 어떤 목적을 가졌고, 어떤 자료형을 이용할껀지 설계
        - 2단계 : 함수형 인터페이스를 이용하여 동작 전달
            - 파라미터와 반환형에 맞춰 함수형 인터페이스 설계
        - 3단계 : 동작 실행
            - 상속된? 클래스 메서드에 람다 함수가 잘 이용될 수 있게끔 커버 제작
        - 4단계 : 람다 전달
            - 람다를 이용해 원하는 파라미터와 반환값 넣기
            
    - 함수형 인터페이스 사용 (다양한 함수형 인터페이스로 문제를 타개할 수 있음)
        - Predicate, Consumer, Function (다양한 함수형 인터페이스)
            - 제네릭을 이용하여 넓은 범위의 람다 함수 구현 가능
        - 기본형 특화 : 박싱, 언박싱, 오토박싱
            - 제네릭은 구현 과정에서 참조형(Integer, Double 등) 형식을 반드시 사용해야 한다. 이는 기본형을 사용할 때 보다 더 많은 메모리를 사용하게 된다.
            - 박싱 : 기본형 → 참조형
            - 언박싱 : 참조형 → 기본형
            - 오토 박싱 : 자바에선 자동적으로 박싱, 언박싱을 적용시켜준다
            - 자바 8에서는 오토박싱을 피할 수 있는 함수형 인터페이스를 제공 (IntPredicate 등)
            - (T, U) → R 표기법으로 함수 디스크립터 설명 가능
            - 자주 사용하는 여러 함수형 인터페이스들이 존재
            
    - 형식 검사, 형식 추론, 제약
        - 형식 검사
            - 람다 표현식의 작동 과정 : 5단계로 나눠지며, 인터페이스에서 정의한 메서드를 시작으로 람다 형식을 확인하여 유효 여부를 판단한다.
        - 같은 람다, 다른 함수형 인터페이스
            - 같은 람다 형식이라도 다른인터페이스에 선언되어 있으면 다른 기능을 가진다
            - 다이아몬드 연산자 : 인스턴스 표현식의 형식 인수는 콘텍스트에 의해 추론된다.
            
            ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/815fcbd8-ca1c-4a06-8509-b42931c4a9b4/Untitled.png)
            
            - 특별한 void 호환 규칙 : 람다 바디에 일반 표현식이 있는 경우
            
                                                      = void를 반환하는 함수 디스크립터
            
        - 형식 추론
            - 함수형 인터페이스로 시그니처를 추가할 수 있으므로 람다 함수 파라미터의 자료형은 생략 가능 ex) (Apple a1, Apple a2) ⇒ (a1, a2) 로 변경 가능
        - 지역 변수 사용
            - 람다 표현식에서 외부 변수(지역 변수)를 사용할 수 있다 → 람다 캡처링
            - 조건 : 외부 변수는 final을 이용하여 한 번만 할당되어야 한다. (변화 x)
            - 이유 : 데이터의 다른 저장 영역에 따른 관리 문제, 프로그래밍 패턴 규칙 위반 문제, 쓰레드 문제
            
    - 메서드 참조
        - 요약
            - 메서드 참조 : 특정 메서드만을 호출하는 람다의 축약형. 특정 메서드만을 호출할 경우 이미 시그니처를 알기 때문에 파라미터를 제거하고 사용할 수 있다
            - :: 를 이용한다.
            - 메서드 참조는 가독성을 높일 수 있다
            - 메서드 참조의 단축 규칙은 3가지로 분류된다
                
                ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/2875748d-ad5a-4d63-a464-0276560bb07b/Untitled.png)
                
        - 생성자 참조
            - 생성자 참조 : 메서드 참조와 같이 생성자를 파라미터 없이 만들 수 있다.
            - ex) Apple::new = new Apple(?) (? : 생성자 시그니처)
            
    - 람다, 메서드 참조 활용하기
        - 1단계 : 코드 전달
            - 두 사과를 비교하는 다양한 방법을 구상하고 설계
        - 2단계 : 익명 클래스
            - 익명 클래스는 선언과 동시에 인스턴스화 하며, 일회용으로 쓰기 좋다
        - 3단계 : 람다 표현식 사용
            - 람다 표현식으로 더욱 간단하게 선언을 변경
            - 파라미터 형식이 추측 가능하기 때문에 (Apple a) 를 (a)로 변경 가능
            - 정렬을 하는 경우 하나의 키를 기준으로 하는 Comparator.comparing을 이용할 수 있다. → 코드 축소 가능
        - 4단계 : 메서드 참조 사용
            - 메서드 참조로 파라미터와 반환값을 합칠 수 있다 → 코드 축소의 완성
            
    - 람다 표현식을 조합할 수 있는 유용한 메서드
        - 사용 이유
            - 다양한 함수형 인터페이스가 람다 표현식을 조합할 수 있도록 유틸리티를 제공 → 람다식의 정밀한 표현이 가능
            - 디폴트 메서드를 이용하여 함수형 인터페이스의 정의에 어긋나지 않고 다양한 기능을 제공
        - Comparator 조합
            - 정렬을 다양한 요소로 정밀하게 표현 가능
            - ex) inventory.sort(comparing(Apple::getWeight) // 무게 순으로 정렬
                                             .reversed() // 역정렬
                                             .thenComparing(Apple::getCountry)); // 같은 무게 → 나라 정렬
                
        - Predicate 조합
            - and, or, negate(특정 프리티케이트 반전) 지원
            - 작은 프리티케이트를 직관적으로 묶어 더욱 크게 만들 수 있음
            - ex) Predicate<Apple> apple = redApple.and().or().negate();
        - Function 조합
            - 람다 함수를 파이프라인 형식으로 제작 가능
            - 수학적으로 사용 가능
            - .andThen()을 이용
            
    - 비슷한 수학적 개념
        - 적분
        - 자바 8 람다로 연결
        
    - 마치며
        - 람다 표현식은 익명 함수의 일종. 이름은 없지만, 파라미터, 바디, 반환값을 가지며 예외를 던질 수 있음
        - 람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급
        - java.util.function 패키지에서 Predicate<T>, Function<T, R>, Supplier<T> 등 다양한 함수형 인터페이스와 그에 맞는 유틸리티를 제공
        - 오토박싱을 피할 수 있는 함수형 인터페이스가 존재
        - 실행 어라운드 패턴을 람다와 활용하면 유연성과 재사용성을 얻을 수 있음
        - 메서드 참조를 이용하면 기존의 메서드 구현을 재사용하고 직접 전달할 수 있음
