# 1장
## 자바 8의 대표적 새로운 기술
- 스트림 API
- 메서드에 코드를 전달하는 기법
- 인터페이스의 디폴트 메서드
조금 다른 관점으로보면 추가된 스트림 API 덕분에 메서드 코드 전달 기법 & 인터페이스의 디폴트 메서드가 존재할 수 있다. 

## 자바 8 설계의 세가지 프로그래밍 개념
### 스트림 처리 
- 스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- 자바 8에서 java.util.stream 패키지에 스트림 API가 추가
- 스트림 API의 핵심은 작업을 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것 & CPU 코어에 할당
### '동작 파라미터화' 로 메서드에 코드 전달하기
- 코드 일부를 API로 전달하는 기능
### 병렬성과 공유 가변 데이터
- 스트림 메서드로 전달하는 코드의 동작 방식을 바꾸어 병렬성을 얻자는 아이디어
- 함수형 프로그래밍 vs 명령형 프로그래밍?


## 자바 함수
- 일급 값, 이급 시민의 차이로 인한 불편함?
- 런타임에 메서드를 전달할 수 있다면(메소드를 일급 시민으로 만든다면) 유용하게 활용할 수 있다

메소드 참조
자바 8에서는 메소드를 일급 값으로 취급하고, 메소드 ㅈ참조를 만들어 전달할 수 있게 되었다. 

람다 : 익명함수
이용할 수 있는 편리한 클래스, 메서드가 없을때 람다 문법을 이용하면 더욱 편리하게 코드를 구현할 수 있다.

사용자의 요구사항에 맞추어 코드를 구현했다. 하지만 사용자가 기능 추가를 요청했을 때 복사, 붙여넣기는 모든 코드를 다 바꿔야하는 상황에 놓일 수 있기에 '코드를 인수로 넘겨주는 방법'으로 상황에 유연하게 대처가 가능하다. 

메서드를 값으로 전달하는 것은 유용한 방법이지만, 매번 메서드를 정의하는 것은 힘든 일. 따라서 메소드가 아닌 '람다'를 사용하면 훨씬 간결해진다. 

멀티스레딩은 어렵다. 병렬성은 컨트롤하는 것은 어렵지만, 자바 8의 스트림 API로 문제들을 해결했다. 필터링, 추출, 그룹화하는 기능들을 쉽게 병렬화할 수 있다는 점도 변화의 동기가 되었다. 

디폴트 메서드와 자바 모듈
자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다. 디폴트 메소드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다. 

### 프로그래밍 핵심적 두 아이디어
- 메서드 & 람다 일급값으로 사용
- 가변 공유가 없는 병렬 실행을 이용해서 함수나 메소드를 호출할 수 있다는 것


## 1장 결론
- 자바 8은 더 효과적이고 간결하게 구현할 수 잇는 새로운 개념과 기능을 제공
- 함수는 일급값
- 여러 불편한 점들이 있었고, 그런 점을 개선하기 위해 이후 개념들을 사용한다.

---
# 2장. 동작 파라미터화 코드 전달하기
## 변화하는 요구사항에 대응
평소 변화하는 요구에 맞추어 코드를 짤 때 flag와 같은 파라미터를 사용했지만 이는 매우 형편없는 코드
### 동작의 파라미터화 
프레디케이트 & 선택 조건을 결정하는 인터페이스를 활용해서 동작을 정의
즉, 인터페이스를 만들어두고 원하는 동작을 하는 class에 implements 통해 특정 행위를 구현하고 호출하는 방법을 사용한다(캡슐화)
> ? 의문점 ?  그럼 결국 동작의 파라미터화라는 것은 원하는 함수를 구현해서 그 함수를 넘겨주는 방식으로 이루어지는 것인가? -  맞는듯?

### 복잡한 과정 간소화
새로운 동작을 전달하려면 여러 클래스를 정의한 다음에 인스턴스화해야 한다.
위의 불편함을 해소하기 위해 **익명 클래스** 기법을 제공한다. 
``` java
List<Apple> redApples = filterApples(inventory, new ApplePredicate(){
	public boolean test(Apple apple){
    	return RED.equals(apple.getColor());
    }
});
```
익명 클래스 또한 많은 공간을 차지한다. 이를 해결하기 위해 **람다 표현식**을 사용
``` java
List<Apple> result = filterApples(inventory, (Apple apple) -> RED.equals(apple.getColor()));
```

### 람다를 이용한 실전 예제
- Comparator
- Runnable
- Callable


## 2장 결론
- 동작 파라미터화에서는 메소드 내부적으로 다양한 동작을 수행할 수 있도록 메소드 인수로 코드를 전달
- 동작을 파라미터화 하며 얻을 수 있는 많은 이점이 존재한다.


---
# 3장. 람다 표현식
## 람다란
> 메서드로 전달할 수 있는 익명 함수를 단순화한 것

```java
(Apple a1, Apple a2) 	-> 			a1.getWeight().compareTo(a2.getWeight());
// 람다 파라미터  		//화살표 			//람다 바디
```

함수형 인터페이스 : 정확히 하나의 추상 메서드를 지정하는 인터페이스
람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있다. 

### 함수 디스크립터
함수형 인터페이스 의 추상 메서드 시그니처는 람다 표현식의 시그니처를 가르킨다. 
람다 표현식의 시그니처를 서술하는 메서드를 **함수 디스크립터**라고 부른다. 
> ?의문점? 시그니처란 정확히 무엇을 뜻하는가? 함수와 같은 말인가? 인자와 반환값이 없는 시그니처로 칭했으니.??
> ?의문점2? page 96. 3번이 틀린이유는 Predicate의 형이 boolean인데 반환을 Integer로 해서인가?

### Predicate
제네릭 형식의 T의 객체를 인수로 받아 불리언을 반환하는데, 특정 상황 불리언 표현식이 필요한 곳에서 사용 가능
``` java
public interface Predicat<T>{ boolean test(T t); }
Predicate<String> nonEmptyStringPredicate = (String s) -> !s.isEmpty();
```

### Consumer
제네릭 형식 T 객체를 받아 void를 반환하는 accept라는 추상 메소드를 정의, 특정 동작을 수행하고 싶을 때 사용

### Function
제네릭 형식 T를 인수로 받아 제레닉 형식 R 객체를 반환하는 추상 메서드 apply를 정의, 특정 동작을 맵핑하고 싶을 때 사용

### 형식 추론
자바 컴파일러는 람다 표현식이 사용된 콘텍스트(형식)를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론한다. 즉, 컴파일러는 람다의 시그니처를 추론할 수 잇다. 따라서 컴파일러는 람다 표현식의 파라미터 형식에 접근할 수 있으므로 이를 생략할 수 있다.
``` java
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().comparedTo(a2.getWeight());
Comparator<Apple> c = (a1, a2) -> a1.getWeight().comparedTo(a2.getWeight());
```

### 람다 캡처링
익명 함수가 하는 것처럼 외부에서 정의된 변수를 사용할 수 있다. 이와 같은 동작을 람다 캡처링이라고 부른다.
**! 람다 표현식은 한 번만 할당할 수 있는 지역 변수를 캡처할 수 있다.(final 또는 바뀌지 않는)**

### 람다보단 메서드 참조가 더 좋아?
때론 람다 표현식보단 메서드 참조를 사용하는 것이 가독성이 좋고, 자연스러울 수 있다. 
``` java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));
inventory.sort(comparing(Apple::getWeight));
```
람다가 메서드를 호출하라고 명령하는 것보다 직접 참조하는 것이 더 편리하기 때문에 사용한다. 

