# 4. 스트림 소개

## 4.1 스트림이란?
### 스트림
- 자바 8 API에 새로 추가된 기능
- 스트림을 이용해 선언형으로 컬렉션 데이터를 처리할 수 있다. (선언형이란? 임시 구현 코드 대신 질의로 표현하는 것)
- 멀티스레드 구현 없이 투명하게 병렬로 처리 가능
- 즉, **선언형**, **조립 가능**, **병렬화**의 특징을 갖게 해준다.
- 스트림은 데이터의 흐름이고, 스트림 api는 데이터의 흐름을 다루기 쉽게 만든 api이다.

## 4.2 스트림 시작
자바 8 컬렉션에 스트림을 반환하는 stream 메소드가 추가
> 스트림이란, '데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소'

### 스트림 특징
- 파이프라이닝 : 스트림 연산은 대부분 스트림 자신을 반환한다. 그 덕에 laziness, short-circuiting과 같은 최적화 가능
- 내부 반복 : 명시적 반복이 아닌 내부 반복을 지원

## 4.3 스트림과 컬렉션
컬렉션 : **모든** 값을 메모리에 저장하는 자료구조 & 외부 반복
스트림 : **요청할 때만** 요소를 계산하는 자료구조 & 탐색된 스트림 요소는 소비 & 내부 반복

## 4.4 스트림 연산
### 중간 연산 vs 최종 연산
중간 연산
- 다른 스트림을 반환
- 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않는다는 것이 특징(이건 최종 연산이 끼면한다는 소린가?)
- 위의 lazy한 특징 때문에 short-circuit 기법 사용가능하고, 다른 연산들이 한 과정을 병합이 가능 ( ex, 루프퓨전 = filter, map이 동시에 실행)

최종 연산
- 스트림 이외에 결과가 반환

선언형이다. 그리서 쿼리문이랑 비슷한 것처럼 느껴짐

---
# 5. 스트림 활용
## 5.1 필터링
프레디케이트 필터링 방법과 고유 요소만 필터링하는 방법
- filter
- distinct
## 5.2 스트림 슬라이싱
스트림 요소를 선택하거나 스킵하는 방법
- takeWhile(), dropWhile : 처음으로 참 또는 거짓이 되는 지점까지 발견된 요소를 버림. filter보다 큰 스트림에서 이득
- limit()
- skip()
## 5.3 매핑
특정 객체에서 특정 데이터를 선택하는 작업
- map
- flatMap => 구체적으로 이해가 잘 안감
## 5.4 검색과 매칭
특정 속성이 데이터 집합에 있는지 여부를 검색하는 데이터 처리
- allMatch, anyMatch, noneMatch, findFirst, findAny

### Optional
> 값의 존재나 부재 여부를 표현하는 컨테이너 클래스
> 아무 요소도 반환하지 않을 경우 null error를 발생시킬 수 있기에 사용

## 5.5 리듀싱
Integer와 같은 결과가 나올 때까지 스트림의 모든 요소를 반복적으로 처리해야하는데 이런 질의를 리듀싱 연산이라 한다. 
```java
int sum = numbers.stream().reduce(0, (a,b) -> a+b);
```
- max, min, sum 

### 리듀스 vs 콜렉트
- 리듀스는 폴드 연산. 쉽게 말해서 두개의 값을 하나로 만든다. 폴드 두개의 면을 하나로 합친다
- 콜렉트는 누적해서 집계한다. 

### 초기값 없는 reduce 연산
초기값을 받지 않는 reduce 연산이 있다. 이 경우 Optional 객체를 반환한다.
```java
Optional<Integer> sum = numbers.stream().reduce((a,b) -> (a+b));
```

### 상태 없음과 상태 있음
map, filter 등의 입력은 스트림에서 각 요소를 받아 결과를 출력 스트림으로 보낸다. 이때 이들은 보통 상태가 없는, 즉 내부 상태를 갖지 않는 연산이다. 
하지만 reduce, sum, max와 같은 연산은 값을 누적할 내부 상태가 필요하다. 스트림에서 처리하는 요소 수와 관계없이 내부 상태의 크리는 한정되어 있다. 
즉, 과거의 이력을 알고 있어야 한다면 내부 상태를 갖는 연산이라 칭한다. 

## 5.7 숫자형 스트림
스트림 API 숫자 스트림을 효율적으로 처리할 수 있도록 **기본형 특화 스트림**을 제공
```java
int calories = menu.stream()
					.map(Dish::getCalories)
                    .reduce(0, Integer::sum)
```
위 코드는 내부적으로 합계를 계산하기 전 Integer를 기본형으로 언박싱해야 하기에 박싱 비용이 숨어있다고 표현한다. 

- mapToInt, mapToDouble, mapToLong을 주로 사용하고, 이들은 map과 같은 기능을 하지만 Stream<T> 대신 특화된 스트림을 반환한다.
  ( 이 부분 궁금한 것 Integer, Double, Long과 같은 특정 형을 반환하는 것인가? )
- boxed() : 객체 스트림으로 복원
  
## 5.8 스트림 만들기
- stream.of
- System.getProperty : 제공된 키에 대응하는 속성이 없으면 null을 반환
- Arrays.stream() => ```int sum = Arrays.stream(numbers).sum(); // 여기서 Arrays.stream은 IntStream을 반환하는데 다른 경우는? ```

### 무한 스트림 만들기
무한한 값을 만들 수 있기에 보통 limit, iterate 메소드에서 지원하는 프레디케이트, 프레디케이트와 함께 쓰인다.
```java
IntStream.iterate(0, n->n < 100, n-> n+4)
  		 .forEach(System.out::println);
//밑은 틀린 것. 프레디케이터가 없어서 언제 끝날지 모름
IntStream.iterate(0, n->n+4)
  		 .filter(n-> n < 100)
         .forEach(~~)
//밑은 맞은 것. takeWhile이 프레디케이터로 언제 끝날지 알려줌
IntStream.iterate(0, n->n+4)
  		 .takeWhile(n->n<100)
         .forEach(~~)          
```
