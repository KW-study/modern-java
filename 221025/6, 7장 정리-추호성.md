# 6, 7장

1. 스트림으로 데이터 수집
    1. collect(), Collector, Collectors
        - collect() : Collector를 매개변수로 하는 스트림의 최종 연산
        - Collector : collect()에서 필요한 메서드를 정의해놓은 인터페이스(Supplier, BiConsumer, BinaryOperator, Function, Set)
        - Collectors : Collectors 클래스는 다양한 기능의 Collector를 구현한 클래스 제공(변환, 통계, 결합, 리듀싱, 분할 등)
        
    2. Collectors 클래스
        - Collectors 클래스가 제공하는 메서드는 3가지로 분류된다.
        - 리듀싱과 요약
            - 스트림의 요소를 하나의 결과로 합치거나 다른 형식으로 도출할 수 있다
            - counting : 스트림 요소의 개수를 반환한다.
            - maxBy, minBy : 최대, 최솟값을 반환한다. Optional 컨테이너가 필요하다.
            - summingInt, averagingInt, summarizingInt : 총합, 평균, 전체 정보를 반환한다. 이를 요약 연산이라고 한다.
            - joining : 스트림의 요소에서 문자열을 추출해 이어서 반환한다. 매개변수로 구분자 사용이 가능하다.
            - 범용 리듀싱 요약 연산 : Collectors.reducing 메서드는 요약 연산을 커스터마이징 할 수 있다. 프로그래밍적 편의성이 목적이며(가독성은 떨어진다), 3개의 파라미터를 받는다. 한개의 인수를 받을수도 있다.
                - 첫번째 파라미터 : 시작값
                - 두번째 파라미터 : 변환 함수(map 느낌)
                - 세번째 파라미터 : 두개의 변수를 하나로 줄이는 operator
            - 같은 연산도 다양한 방식으로 수행할 수 있다.(reducing, map.reduce.get 등) → 가독성과 성능을 모두 잡는 방향으로 움직이자.
        - 그룹화
            - 스트림의 요소를 하나 이상의 특성으로 분류해서 그룹화하는 연산이다. 이를 분류함수라고 한다.
            - collect(groupingBy(특성)) 형식으로 사용하며, 분류 기준이 key이며 분류된 스트림 항목을 value(형식은 인수에 맞춰진다)로 갖는 map이 반환된다.
            - 람다 표현식으로 분류 로직을 구현할 수 있다.
            - groupingBy() 함수는 팩토리 메서드로 여러 변수를 받을 수 있다. → 높은 자유도를 가진다.
            - 여러 수준으로 그룹화 할 수 있다. groupingBy(분류 기준, groupingBy(분류 기준…)) 형식이다. n 수준의 그룹화는 n수준의 트리와 같다.
            - groupingBy(f) = groupingBy(f, toList()) 이다. toList() 이외에 다양한 최종 연산을 입력할 수 있다.
            - 컬렉터 결과를 다른 형식에 적용 가능하다. collectingAndThen() 함수는 적용할 컬렉터와 변환 함수를 받아 다른 컬렉터를 반환한다.
            - ex) .collect(groupingBy(Dish::getType, collectingAndThen(maxBy(comparingInt(Dish::getCalories)), Optional::get))); → 스트림을 Dish::getType으로 분류한 다음 각 서브 스트림에서 칼로리를 기준으로 최댓값을 뽑은 뒤 반환한다.
        - 분할
            - 불리언 함수로 스트림의 요소를 TF로 분할한다. 그룹화의 일부라고 생각하면 된다.
            - partitioningBy(분할 함수, 다른 메서드) 형식을 이용한다. 형식을 이용한다. (다른 메서드 : collectingAndThen(), groupingBy())
        - 예제) 숫자를 소수와 비소수로 분류하기
            - 소수 판별 함수를  noneMatch() 메서드로 제작한 뒤, partitioningBy() 메서드로 거른다.
            
    3. Collector Interface
        - T, A, R을 인수로 받는다. T는 수집될 스트림 항목의 자료형, A는 누적자, R은 수집 연산 결과 객체의 형식이다.
        - 다섯 가지 메서드가 존재한다.
            - Supplier<A> supplier() : 빈 결과로 이루어진 Supplier를 반환한다. 빈 누적자 인스턴트를 만들어준다.
            - BiConsumer<A, T> accumulator() : 리듀싱 연산을 수행하는 함수를 반환한다. n번째 요소를 탐색할 때, 누적자와 n번째 요소를 함수에 적용한다. (연산 과정에서 반복되어 호출, 연산되는 메서드)
            - Function<A, R>finisher() : 누적자 개체를 최종 결과로 변환하면서 누적 과정을 끝낼 때 호출할 함수를 반환한다.
            - BinaryOperator<A> combiner() : 스트림의 서브 파트를 병렬로 처리할 때 누적자가 어떻게 처리할지를 정의한다.
            - Set<Characteristics> characteristics() : 스트림의 최적화 전략을 정의한다. UNORDERED, CONCURRENT, IDENTITY_FINISH 가 존재한다.
        - 메서드의 작동 방식 : characteristics로 최적화 전략 구축 → 스트림을 조건에 맞게 분할 → supplier, accumulator, finisher 함수로 각 스트림을 병렬 연산 → combiner로 분할된 스트림을 병합 → 결과 도출
        - 위 메서드를 정의하여 컬렉터를 커스터마이징 할 수 있다. 기존 컬렉터에 존재하지 않는 법칙 혹은 기능을 추가할 수 있다는 장점, 성능을 특화할 수 있다는 장점이 있다.
        - Collector Interface의 커스터마이징 단계
            1. Collrctor 클래스 시그니처 정의
            2. 다섯가지 메서드 구현 (목적과 최적화 방법 생각)
            3. 기존 컬렉터와 성능 비교
            
2. 병렬 데이터 처리와 성능
    1. 스트림 성능 측정
        - 스트림 연산이 항상 빠른 것은 아니다. 어떤 경우에 더 빠르고 효율적인지 판단하기 위해선 확실한 작동 원리를 알아야 한다.
        - 효과적인 스트림 연산을 원한다면, 스트림 선택 문제, 자료구조 문제(박싱) 등 여러 방면에서 신경써야 한다.
        
    2. 병렬 스트림
        - 병렬 스트림 : 스트림이 여러 청크로 분할되어 있어 연산을 병렬로 수행할 수 있는 스트림. 병렬 스트림으로 변경할 경우 내부적으로 병렬 연산 플래그가 설정된다.
        - parallel로 순차 스트림을 병렬 스트림으로, sequential로 병렬 스트림을 순차 스트림으로 변경할 수 있다.
        
    3. 병렬 스트림의 사용법
        - 병렬 스트림이 올바로 동작하라면 공유된 가변 상태를 피해야 한다. 공유된 가변 상태란, 다수의 스레드에서 동시에 데이터에 접근하는 상태를 뜻하나?
        - 병렬 스트림이 효과적인지 확신이 없다면 직접 측정해야 한다.
        - 박싱을 조심해야 한다. 박싱은 성능을 크게 저하시키는 요소다.
        - limit, findFirst 등 일부 메서드는 순서가 중요하기 때문에 순차 스트림보다 병렬 스트림에서 성능이 떨어진다. findFirst → findAny를 이용하자
        - 스트림에서 수행하는 전체 파이프라인 연산 비용을 고려해야 한다. 하나의 요소를 처리하는데 드는 비용이 높아진다는 것은 병렬 스트림으로 성능을 개선시킬 수 있다는 가능성이 있음을 의미한다.
        - 대량의 데이터에 이용해야 한다.
        - 스트림을 구성하는 자료구조가 적절한지 확인해야 한다. ArrayList가 LinkedList보다 효과적으로 분할 할 수 있다. 기본형 스트림도 마찬가지로 쉽게 분할할 수 있다.
        - 중간 연산이 스트림 분할에 큰 영향을 미칠 수 있다. filter 메서드를 적용한 후 나온 결과는 그 수를 예측할 수 없기 때문에 병렬 처리에 큰 어려움이 될 수 있다.
        - 최종 연산의 병합 과정의 값을 잘 따져야 한다. 값이 비싸다면 병렬 스트림의 의미가 퇴색된다.
        
    4. 포크/조인 프레임워크
        - 자바7에서 사용된 태스크 분할 및 병렬화 작업을 위한 프레임워크다.
        - 분할(포크)-정복(조인) 알고리즘을 이용하여 병렬화를 진행한다.
        - 포크/조인 프레임워크의 올바른 사용법
            - 두 서브 테스크가 모두 시작된 다음 join 메서드를 이용하자.(join은 결과가 나오기 전까지 호출자를 블록시킨다)
            - 순차 코드에서 병렬 계산을 시작할 때만 invoke를 사용하자 (invoke는 함수를 동적으로 실행해준다)
            - 각 서브 테스크에 fork와 compute를 실행하면 자원 관점에서 효과적이다
            - 디버깅이 어렵다
            - 포크/조인 프레임워크는 언제나 빠른것은 아니다.
        - 작업 훔치기
            - 모든 스레드에 테스크를 공정하게 분할하는 도구
            - 먼저 일을 끝낸 스레드가 다른 스레드 큐에서 작업을 훔쳐오는 방식이다
        
    5. Spliterator Interface
        - 인터페이스이며, 분할 로직 없이 스트림을 자동으로 분할해주는 역할을 한다.
        - 파라미터는 T이며, 탐색하는 요소의 형식을 가르킨다. 또한 네 가지 메서드가 존재한다.
            - tryAdvance() : 탐색할 요소가 있으면 참을 반환
            - trySplit() : Spliterator의 일부 요소를 분할하여 두번째 Spliterator를 생성한다.
            - estimateSize() : 탐색해야할 요소 수 정보를 반환한다. (추정치를 반환할 수도 있다)
            - characteristics() : Spliterator 자체의 특성 집합을 포함하는 int를 반환한다.
        - 커스터마이징 가능하다.
