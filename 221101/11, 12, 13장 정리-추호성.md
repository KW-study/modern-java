# 11, 12, 13장

1. Optional 클래스
    1. Optional 클래스의 소개
        - null은 많은 문제(에러 문제, 철학 문제, 시스템 문제 등) 를 야기한다. 기존의 null 대처법은 비효율적이다. 이 때문에 null을 효율적으로 대처하고 의미를 부여하는 장치가 필요하다. → Optional 클래스 (개인적 생각)
        - Optional<> 형태로 사용하며, Optional 객체를 반환한다.
        - Optional은 코드를 더욱 쉽게 이해할 수 있도록 도와준다. Optional은 Null이 있을 수 있음을 명시하며, 이에 대한 대처를 직관적으로 표현해준다. → 무분별한 Optional 남용은 좋지 않다.
        - Optional 객체를 최대 요소의 개수가 한 개 이하인 데이터 컬렉션으로 생각할 수 있다.
        
    2. Optional 적용 패턴
        - Optional 선언
            - 빈 Optional : Optional.empty()로 빈 Optional 객체를 얻을 수 있다.
            - null이 아닌 값으로 optional 만들기 : Optional.of()
            - null값으로 optional 만들기 : Optional.ofNullable();
        - Map을 이용한 Optional의 추출 및 변환
            - 스트림과 비슷하게 map을 이용하여 데이터를 추출 및 변환할 수 있다.
            - Optional이 값을 포함하면 변환, 그렇지 않으면 아무 일도 일어나지 않는다.
            - FlatMap을 이용하여 Optional 중첩을 막을 수 있다.
            - 호출, 참조 체인을 만들 수 있다.
            - 자바 9 이후부턴 Optional 스트림 조작이 가능하다. (filter와 map을 이용하여 더욱 쉽게 구현이 가능하다)
        - 디폴트 액션과 Optional 언랩
            - get() : 값을 읽는 가장 간단한 메서드. Optional 이 값을 포함하지 않는 경우 예외를 발생시킨다.
            - orElse() : Optional이 값을 포함하지 않는 경우 기본값을 제공할 수 있다.
            - orElseGet() : orElse()의 lazy 버전. Optional에 값이 없을 때만 인수가 실행된다.
            - orElseThrow() : Optional 값이 비어있을 경우 예외를 발생시킨다. 예외 선택 가능
            - ifPresent() : 값이 있을 경우 인수로 넘겨준 동작을 실행.
            - ifPresetorElse() : 자바 9에서 사용 가능. runnable을 추가 인수로 받는다.
        - 필터로 특정 값 거르기
            - filter를 이용하여 데이터를 거를 수 있다.
            - Optional 객체가 값을 가지며 predicate가 일치하면 filter는 그 값을 반환하고 그렇지 않으면 빈 Optional 객체를 반환한다.
        - 다양한 Optional 클래스의 메서드가 존재한다.
        
    3. Optional 실전 적용 예제
        - 잠재적으로 null이 될 수 있는 대상을 Optional로 감쌀 경우 안전하게 사용할 수 있다.
        - Optional을 이용하여 기존 함수를 커스터마이징 할 수 있다. → 예외로부터 안전해진다.
        
2. 새로운 날짜와 시간 API
    1. 날짜와 시간 표현 클래스
        - 사람이 보는 시간 클래스
            - 날짜와 시간을 표현하는 불변 객체
            - LocalDate : 연도, 달, 요일 등 날짜를 반환하는 메서드를 제공
            - LocalTime : 시, 분, 초 등 시간을 반환하는 메서드를 제공
            - LocalDateTime : 날짜와 시간을 쌍으로 갖는 복합 클래스
        - 기계가 보는 시간 클래스
            - Instant 클래스 : 특정 지점까지의 시간을 초로 표현한다.
            - Instant 클래스는 나노초(10억분의 1초)의 정밀도를 제공한다.
            - 사람이 보는 시간 클래스와 연결할 수 없다.
        - 지속 시간 측정 클래스
            - Duration
                - between 메서드로 두 시간 객체 사이의 지속시간을 만들 수 있다.
                - 시, 분, 초 등 작은 단위가 필요할 때 사용한다.
                - LocalTime, LocalTimeDate, Instant 만 사용 가능하다. 같은 클래스만 사용 가능하다.
            - Period
                - between 메서드로 두 시간 객체 사이의 지속시간을 만들 수 있다.
                - 일, 월, 년도 등 큰 단위가 필요할 때 사용한다.
                
    2. 날짜 조정, 파싱, 포메팅
        - 조정
            - 상대적 혹은 절대적 방식으로 LocalDate의 속성을 변경할 수 있다.
            - TemporalAdjuster 인터페이스로 복잡한 날짜 조정이 가능하다.
        - 파싱과 포메팅
            - parse를 이용하여 문자열을 날짜 객체로 만들 수 있다.
            - DateTimeFormatter로 날짜나 시간을 특정 형식으로 문자열로 만들 수 있다.
            - DateTimeFormatterBuilder를 이용하여 세부적으로 포메터를 제어할 수 있다.
            
    3. 다양한 시간대와 캘린더  활용법
        - 표준 시간이 같은 지역을 묶어서 시간대 규칙 집합을 정의한다. 약 40개가 존재한다.
        - 특정 시점의 시간대를 적용할 수 있다.
        
3. 디폴트 메서드
    1. 디폴트 메서드란?
        - 상속된 클래스에서 구현 의무를 가지지 않는 인터페이스 내의 메서드
        - 기존 (자바 8 이전) 자바에서는 인터페이스를 구현하는 클래스는 인터페이스의 모든 메서드를 강제적으로 구현해야 했다. → 인터페이스에 메서드가 추가될 경우, 이를 상속하는 모든 클래스를 수정해야 하는 문제가 생긴다. → 정적 메서드와 디폴트 메서드가 생긴 이유
        - 메서드 앞에 default 예약어를 붙여야 하며, 구현부에 {}가 있어야 한다.
        - 용어 정리
            - 정적 메서드
                - 객체 생성 없이 직접 호출할 수 있는 메서드
                - 인터페이스에 구현할 수 있으며, 상속된 클래스에서 사용할 수 있다.
                - 단, 클래스 명으로 호출해야 하며, 재정의 불가능하다.
            - 디폴트 메서드
                - 인터페이스에서 메서드 구현이 가능하다.
                - 참조 변수로 함수를 호출할 수 있다.
                - 구현된 클래스에서 재정의 가능하다.
            - 추상 클래스
                - 하나 이상의 추상 메서드를 포함한 클래스다. 추상 메서드란, 함수 선언만 되어있구 구현부가 없는 메서드를 의미한다.
                - 클래스는 하나의 추상 클래스만 상속 받을 수 있지만, 인터페이스를 여러 개 구현할 수 있다.
                - 인스턴스 변수(클래스 내부에 정의된 변수)로 공통 상태를 가질 수 있는 반면, 인터페이스는 인스턴스 변수를 가질 수 없다.
                - [https://dahyeee.tistory.com/entry/JAVA-interface-default-static메소드](https://dahyeee.tistory.com/entry/JAVA-interface-default-static%EB%A9%94%EC%86%8C%EB%93%9C)
                
    2. 변화하는 API에 대한 기존 자바의 문제점
        - 기존 배포한 라이브러리의 인터페이스에 메서드를 추가할 경우 다음과 같은 문제가 발생한다.
            - 인터페이스를 이용한 모든 클래스는 메서드를 추가 구현해야 한다.
            - 호환성 문제가 발생한다.
        - 호환성
            - 바이너리 호환성 : 무언가를 바꾼 후에도 에러 없이 기존 바이너리가 실행될 수 있는 상황
            - 소스 호환성 : 코드를 고쳐도 기존 프로그램을 성공적으로 재컴파일 할 수 있는 상황
            - 동작 호환성 : 코드를 고친 후에도 같은 입력이 주어지면 프로그램이 같은 동작을 실행하는 상황
            
    3. 디폴트 메서드의 활용 패턴
        - 디폴트 메서드를 이용하는 다른 방식이 존재한다.
        - 선택형 메서드
            - 인터페이스 중 사용하지 않는 메서드를 디폴트 메서드로 구현해 상속된 클래스에서 불필요한 코드를 줄일 수 있다.(인터페이스에 적힌 코드를 그대로 이용하면 된다)
        - 동작 다중 상속
            - 디폴트 메소드는 동작 다중 상속 기능도 구현할 수 있다.
            - 클래스가 필요한 기능을 가진 인터페이스를 쉽게 상속 받으면서 조합하고 사용할 수 있게 한다.
            - 적은 기능을 사용하기 위해 많은 메서드가 존재하는 인터페이스를 상속받는건 옳지 못하다. 멤버 변수를 이용하여 필요한 메서드를 직접 호출하는 메서드를 작성하는 방법이 있다. → 이를 델리게이션(대표단)이라고 한다.
            
    4. 해석 규칙
        - 부모 클래스의 상속, 여러 인터페이스의 상속이 가능하게 되면서 같은 시그니처를 갖는 디폴트 메서드를 상속받는 상황이 생긴다. → 규칙이 필요하다.
        - 세 가지 해결 규칙
            - 클래스가 항상 이긴다. 클래스나 슈퍼클래스에서 정의한 메서드가 디폴트 메서드보다 우선이다.
            - 위 규칙 이외의 상황에선 서브 인터페이스가 이긴다. 상속 관계를 맞는 인터페이스에선 서브 인터페이스가 이긴다. (A implements B에서 A는 서브 인터페이스, B는 슈퍼 인터페이스다.)
            - 위 규칙 이외의 상황에선 어떤 디폴트 메서드를 사용할껀지 명시해야 한다.
