# PART 4 - 매일 자바와 함께

## 11. null 대신 Optional 클래스

- null때문에 발생하는 문제
    - NullPointerException → 걍 극혐. 왜 문제인지 찾기 개어려움
    - 코드를 어지럽힘. if (Object is Null?) 과 같은 코드때문에 if 중첩 depth가 늘어나고 가독성이 똥이됨.
    - null을 의도해서 사용했어도 문제임. 왜 null이 사용되었는지 의미를 파악하기 개어려움.
- 요즘 언어들은 null을 없애려고 하는 추세. kotlin만 해도 null이 발생할것 같으면 걍 컴파일 에러 때림.
- 그래서 자바에선 하스켈(mayBe)과 스칼라(Option)의 영향을 받아서 Optional 클래스를 만듬
- Optional: 선택형 값을 캡슐화 하는 클래스. 즉, 값이 없을 수 있다! 라는 걸 명시적으로 알려주는 클래스임. Car car = getCar() 을 했을때 getCar의 반환값이 null이라면 null참조라서 NPE가 되었을텐데, Optional<Car>이라면 그냥 null이어도 ㄱㅊ음. 값이 없을 수 있기 때문을 내포하고 있기 때문에.
    - get, orElse, orElseGet, orElseThrow, ifPresentOrElse와 같은 메서드들로 옵셔널을 unwrap할 수 있다.
    - 나머지 필요한 기능들은 그때그때 찾아보면 될듯.
- 다만 모든 null참조를 optional로 대체하는 것은 옳지 않음. 진짜 값이 꼭 필요한 객체라면 NPE가 떠야 프로그래머의 실수를 놓치지 않을 수 있기 때문.

## 12. 새로운 날짜와 시간 API

- 자바 기본 날짜 패키지들이 문제가 많아서 joda-time이란 서드 파티 라이브러리가 유용하게 쓰였는데 자바에선 이를 흡수함.
    - 날짜, 시간 API가 중요한 이유는, DB에 우선 created_at, updated_at 등과 같이 사건의 히스토리 타임을 남길때 중요하고, 이들을 시간순으로 정렬하거나, 30일이 지났는지, 한달이 지났는지 등 확인하거나 계산해야 할 일이 은근히 실무에 많다.
- LocalDateTime, LocalDate: 시간포함, 미포함 하는 날짜를 표현하는 불변 객체.
- Instant: 기계의 날짜와 시간. Unix Epoch Time을 기준으로 특정 지점까지의 시간을 초로 표현. Instant.ofEpochSecond 를 이용해서 시간 표현.
- Duration, Period: 두 시간 객체 사이의 지속시간을 만드는 클래스. between 및 여러 메서드가 존재.
- TemporalAdjusters: 조금 더 복잡한 날짜 조정기능이 필요한 경우 사용할 수 있는 클래스.
- DateTimeFormatter: 날짜나 시간을 특정 형식의 문자열로 만들어줌.
- ZoneId: 시간대를 간단하게 처리할 수 있도록 해줌.
    - `TimeZone.getDefault().toZoneId();` 와 같은 코드를 통해서 ZoneId를 얻어낼 수 있음.
- ZoneOffset: GMT 기준으로 차이.
- 근데 이거야 말로, 진짜 필요할때 직접 검색하면서 해도 될 것 같음.
  
## 번외 8, 9, 10장에서 공유하고 싶은 내용

### 꼬리 호출 최적화(꼬리 재귀, 공재귀)
  
꼬리 재귀라는게 있는데, 일반적으로 재귀는 function call을 할 때마다 호출부에 대한 컨텍스트를 스택 프레임에 차곡차곡 쌓는다. 

만약 굳이 스택에 쌓을 필요가 없는 형태의 재귀라면 이 모든게 오버헤드임.
  
  따라서 값을 레지스터에 누적하면서 쌓아가고 max depth에 도달해서 연산이 끝나면 재귀를 종료시켜 최적화 하는 것.
  (ex: function return시 특별한 연산이 없는 경우) 
  
  ```python
  def function(number):
      if number == 1:
          print("leaf")
          return
      function(number-1)
  ```
  
  위 함수의 경우 저 모든 function 콜을 스택프레임에 쌓는게 손해이기 때문에 그냥 number 값에 대한 연산만 레지스터에서 간략하게 처리하는 방식이다.
  
  이는 사용하는 언어의 컴파일러가 지원을 해줘야 하는 부분이다. 코틀린, 스칼라등 함수형 프로그래밍 언어는 도입이 되어있음. 
  
  ## 13. 디폴트 메서드

- 하위 호환성: 인터페이스가 가진 추상 메서드는 모두 구현해서 사용해야 한다. 만약 새로운 버전에 새로운 추상 메서드가 추가된다면, 불특정 다수의 프로그래머는 해당 메서드가 필요 없음에도 구현해서 사용해야 할 것이다. 따라서 자바 8에서는 인터페이스 내부에 1) 정적 메서드 사용, 2) 디폴트 메서드 사용을 통해 해결할 수 있도록 제공했다.
    - 바이너리 호환성: 업데이트 이후, 기존 바이너리가 실행될 수 있는 상황(???)
    - 소스 호환성: 업데이트 이후, 컴파일에 성공하는 상황(.java → .class)
    - 동작 호환성: 업데이트 이후, 입력값 → 출력이 같게 동작하는 상황.
- 디폴트 메서드: 인터페이스의 구현을 포함하는 메서드. default를 붙이면 됨. private package 랑 헷갈리지 않도록 유의
    - 추상클래스 vs 인터페이스:
        - 클래스는 하나의 추상 클래스만 상속받을 수 있음. 인터페이스는 여러 개 구현할 수 있음.
        - 추상 클래스는 인스턴스 변수(필드)로 **공통 상태**를 가질 수 있음. 하지만 인터페이스는 그게 안됨.
    - 다중 상속이 가능은 해짐. (쓰는게 좋은지는 잘 모르겠음. 헷갈리기만함)
        - 다중 상속에서 다이아몬드 문제를 만난다면? 아래의 규칙대로 처리됨.
            1. 클래스 메서드 > 디폴트 메서드
            2. 서브 인터페이스가 이김. B가 A를 상속받는다면 B의 메서드가 A의 메서드를 이김
            3. 이래도 결정이 안되면 명시적으로 오버라이드 → 호출 해야함.
        - 위임(delegation): 멤버 변수를 이용해서 클래스에서 필요한 메서드를 직접 호출하는 메서드를 작성하는 것이 상속보다 더 좋을 수 있다.
  
  
